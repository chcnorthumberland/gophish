// Create global object if needed.
window.nnl = window.nnl || {};
nnl.appSdkLoaded = Promise.resolve().then(function() {
	// If utils is not loaded, load it.
	if(typeof NNLUtils === 'undefined') {
		var utilsURL = document.querySelector('script[src*="/js/appsdk.js"]').src.replace('appsdk.js', 'utils.js');
		if(document.querySelector('script[src="' + utilsURL + '"]') === null) {
			nnl.utilsLoaded = new Promise(function (resolve, reject){
				var script = document.createElement('script');
				script.src = utilsURL;
				script.onload = resolve;
				script.onerror = reject;
				document.head.appendChild(script);
			});
		}

		return nnl.utilsLoaded;
	}
}).then(function() {
	return NNLUtils.waitForIframe();
}).then(function() {
	return Promise.all([
		NNLUtils.loadScript('fido-client.js'),
		NNLUtils.loadScript('fido-method-ui.js'),
		NNLUtils.loadScript('oob-ui.js'),
		NNLUtils.loadScript('outcome.js'),
		NNLUtils.loadHTML('registrations-list-ui.html', 'nnl-manage-regs-ui-section')
	]);
});

/**
 * Exception thrown by App SDK.
 * @param {string} outcome The error code from Outcome object.
 */

function AppSdkException(outcome) {
	this.name = "AppSdkException";
	this.outcome = outcome;
}

/**
 * This interface defines methods for displaying registered methods
 * @interface IManageRegistrationsLiveData
 */

/**
 * This method is called when the methods need to be updated.
 * @method IManageRegistrationsLiveData#setMethods
 * @param {Array[]} registrations - List of registrations list to show.
 */

/**
 * This method will be called when an Remove and Rename operation is completed.
 * @method IManageRegistrationsLiveData#onOperationCompleted
 * @param {Outcome} outcome - The operation outcome.
 * @param {string} [message] - Error message.
 */

/**
 * This interface defines methods for displaying authentication methods available for registration.
 * @interface IFidoRegistrationLiveData
 */

/**
 * This method is called when the authentication methods need to be updated.
 * @method IFidoRegistrationLiveData#setMethods
 * @param {FidoMethod[]} methods - List of available authentication methods.
 */

/**
 * This method will be called when an Registration or Deregistration operation is completed.
 * @method IFidoRegistrationLiveData#onOperationCompleted
 * @param {Outcome} outcome - The operation outcome.
 * @param {string} [message] - Error message.
 */


/**
 * Represents an authentication method to be displayed.
 * @property {string} title - Authentication method name.
 * @property {string} [icon] - Authentication method icon.
 * @property {boolean} isRegPossible - Specifies whether the authentication method can be registered.
 * @property {string} [aaid] - The authentication methods AAID for UAF authenticators.
 * @property {string} [authenticatorAttachment] - The authentication methods attachment type for FIDO2 authenticators.
 */
var FidoMethod = function() {
	
	this.title = null;
	this.icon = null;
	this.isRegPossible;
	this.aaid = null;
	this.authenticatorAttachment = null;
}

/**
 * @class
 * @classdesc Provides methods to perform FIDO registrations. Used by the UI layer.
 * @param  {SessionData} sessionData Session data indicating user who is trying do registrations.
 * @param {AppSdk} appSdk Instance of AppSdk class, used to do registeration and deregistration.
 * @param {Extras} [extras] Additional data to be passed to server.
 */
var FidoRegistrationController = function(sessionData, appSdk, extras) {
	var _this = this;

	/**
	 * Fetches authentication methods from the server policy which are available to register on the current device
	 * and notifies the IFidoRegistrationLiveData instance to update the UI.
	 * @param {IFidoRegistrationLiveData} liveData IFidoRegistrationLiveData instance that will be notified about operation result.
	 */
	this.onRefresh = function(liveData) {
		ProgressIndicator.getInstance().incCounter();

		appSdk.checkRegPossible(sessionData, extras)
		.then(function(result) {
			var methods = [];
			if(result.additionalInfo != null && result.additionalInfo.authenticators != null) {
				for(var i in result.additionalInfo.authenticators) {
					var authenticator = result.additionalInfo.authenticators[i];
					var method = new FidoMethod();
					method.aaid = authenticator.aaid;
					method.title = authenticator.description;
					method.icon = authenticator.icon;
					method.isRegPossible = authenticator.isAllowed;
					method.authenticatorAttachment = authenticator.authenticatorAttachment;
					methods.push(method);
				}
			}

			liveData.setMethods(methods);
		})
		.catch(function() {
			liveData.setMethods(null);
		})
		.then(function() {
			ProgressIndicator.getInstance().decCounter();
		});
	}

	/**
	 * Executes registration of specified authentication method.
	 * @param {FidoMethod} method - Authentication method to register
	 * @param {IFidoRegistrationLiveData} liveData IFidoRegistrationLiveData instance that will be notified about operation result.
	 */
	this.onRegister = function(method, liveData) {
		ProgressIndicator.getInstance().incCounter();

		var cloneExtras = NNLUtils.cloneObject(extras);
		if(method != null) {
			// Create extension used to filter the authentication methods specified by server policy.
			cloneExtras.extensions = [];
	
			// For FIDO2 method create an extension containing the attachment type for filtering.
			if(method.authenticatorAttachment != null) {
				var extData = {
					authenticatorAttachment: method.authenticatorAttachment
				}
	
				var filterExtension = {
					id: 'noknok.webauthnAuthenticatorFilter',
					data: JSON.stringify(extData),
					fail_if_unknown: false
				}

				cloneExtras.extensions.push(filterExtension);
			}
	
			// For UAF method create an extension containing the AAID for filtering. 
			if(method.aaid != null) {
				let extData = {
					criteria: [method.aaid]
				}
	
				let filterExtension = {
					id: 'noknok.AuthenticatorFilterChain',
					data: JSON.stringify(extData),
					fail_if_unknown: false
				}

				cloneExtras.extensions.push(filterExtension);
			}
		}
		
		// Do the registration.
		appSdk.register(sessionData, cloneExtras)
		.then(function() {
			_this.onRefresh(liveData);
			liveData.onOperationCompleted(Outcome.SUCCESS);
		})
		.catch(function(result) {
			liveData.onOperationCompleted(result.outcome);
		})
		.then(function() {
			ProgressIndicator.getInstance().decCounter();
		});
	}

	/**
	 * Executes deregistration of specified authentication method (only for UAF).
	 * @param {FidoMethod} method - Authentication method to deregister
	 * @param {IFidoRegistrationLiveData} liveData IFidoRegistrationLiveData instance that will be notified about operation result.
	 */
	this.onDeregister = function(method, liveData) {
		ProgressIndicator.getInstance().incCounter();

		// Get existing registrations to find the one corresponding to the AAID specified in the method and current device.
		Promise.all([
			appSdk.getRegistrations(sessionData),
			appSdk.getDeviceId()
		])
		.then(function(results) {
			var registrations = results[0].registrations;
			var thisDeviceId = results[1].deviceID;

			for(var i in registrations) {
				var registration = registrations[i];
				if(registration.device.id === thisDeviceId) {
					for(var j in registration.authenticators) {
						// Decode the handle and check whether it contains the specified AAID.
						var handle = registration.authenticators[j].handle;
						var decoded = atob(handle.replace(/-/g, '+').replace(/_/g, '/'));
						var handleData = JSON.parse(decoded);
						if(handleData[1] === method.aaid) {
							// Deregister the authenticator if AAID has matched.
							return appSdk.deregister(sessionData, handle);
						}
					}
				}
			}
		})
		.then(function() {
			_this.onRefresh(liveData);
			liveData.onOperationCompleted(Outcome.SUCCESS);
		})
		.catch(function(result) {
			liveData.onOperationCompleted(result.outcome);
		})
		.then(function() {
			ProgressIndicator.getInstance().decCounter();
		});
	}
}

/**
 * @classdesc Default implementation of IFidoRegistrationLiveData. Also is responsible for UI updates.
 * @class
 * @implements IFidoRegistrationLiveData
 * @param {FidoRegistrationController} fidoRegistrationController The controller instance that will perform Refresh, Register and Deregister tasks.
 * @param {object} [container] HTML element where the view should be rendered. If not specified, a modal dialog will be presented.
 */
var FidoRegistrationUI = function(fidoRegistrationController, container) {
	var _this = this;

	// Cached method to render again in case of failure.
	var mMethods = [];

	// Load the HTML for registrations view.
	var mIsReady = NNLUtils.loadHTML('fido-registration-ui.html', 'fido-registration-ui-fragment')
	.catch(function() {
		nnl.appSdkLoaded.then(function() {
			NNLToastMessage.show('Failed to load FIDO registration UI');	
		});
	});

	/**
	 * Displays the given authentication methods on the UI.
	 * @param {FidoMethod[]} methods - List of available authentication methods.
	 */
	this.setMethods = function(methods) {
		// Cache methods.
		mMethods = methods;

		// Render methods.
		mIsReady.then(function() {
			// Clean the view then add methods.
			container.innerHTML = '';

			if(methods != null) {
				if(methods.length === 0) {
					// If check policy have not returned method list, show a generic button.
					addGenericMethod();
				} else {
					// Render evailable methods.
					for(var i in methods) {
						addMethod(methods[i]);
					}
				}
			}
		});
	}

	/**
	 * Updates the UI based on operation result.
	 * @param {Outcome} outcome - The operation outcome.
	 * @param {string} [message] - Error message.
	 */
	this.onOperationCompleted = function(outcome, message) {
		// In case of failure render cached method list again.
		if(outcome !== Outcome.SUCCESS) {
			_this.setMethods(mMethods);
		}

		if(outcome !== Outcome.CANCELED) {
			var toastText = 'Operation completed with outcome: ' + outcome;
			if(message) {
				toastText += ('\n' + message);
			}
			NNLToastMessage.show(toastText);
		}
	}

	function addGenericMethod() {
		var regButton = document.createElement('button');
		regButton.innerText = 'Register authenticator';
		regButton.className = 'nnl-dialog-button';
		regButton.addEventListener('click', function() {
			fidoRegistrationController.onRegister(null, _this);
		});

		container.appendChild(regButton);
	}

	function addMethod(method) {
		// Clone the html template for displaying an authentication method available for registration.
		var methodTemplate = document.querySelector('#nnl-fido-method-template').cloneNode(true);
		methodTemplate.removeAttribute('id');

		var title = methodTemplate.querySelector('.nnl-method-text');
		var addButton = methodTemplate.querySelector('.nnl-method-add');
		var toggleButton = methodTemplate.querySelector('.nnl-method-toggle');

		title.innerText = method.title;

		// prepend the icon to the title if available.
		if(method.icon != null) {
			var image = document.createElement('img');
			image.src = method.icon;
			title.prepend(image);
		}

		// For FIDO2 authenticator show only the "Add" button.
		if(method.authenticatorAttachment != null) {
			addButton.disabled = !method.isRegPossible;
			addButton.style.display = 'block';
			if(method.isRegPossible) {
				addButton.addEventListener('click', function() {
					fidoRegistrationController.onRegister(method, _this);
				});
			}
		}

		// For UAF authenticator show a toggle button.
		if(method.aaid != null) {
			toggleButton.style.display = 'block';

			var checkBox = toggleButton.querySelector('input');
			checkBox.checked = !method.isRegPossible;
			checkBox.addEventListener('change', function() {
				if(this.checked) {
					fidoRegistrationController.onRegister(method, _this);
				} else {
					fidoRegistrationController.onDeregister(method, _this);
				}
			});
		}

		// Add the section to the view and show it.
		container.appendChild(methodTemplate);
		methodTemplate.style.display = '';
	}
}

/**
 * @class
 * @classdesc Provides method to show a view that will allow to add or enable/disable FIDO authentication methods. 
 * @param {FidoRegistrationController} fidoRegistrationController The controller instance that will perform the registration and deregistration.
 */
function FidoRegistrationView(fidoRegistrationController) {
	/**
	 * Shows the view with available FIDO authentication methods to add or enable/disable.
	 * @param {Object} container An HTML element where the view should be placed.
	 * @throws {INVALID_ARGUMENT_EXCEPTION} If container is not provided.
	 */
	this.show = function(container) {
		if(container == null) {
			throw new INVALID_ARGUMENT_EXCEPTION('container');
		}

		var ui = new FidoRegistrationUI(fidoRegistrationController, container);
		fidoRegistrationController.onRefresh(ui);
	}
}

var AppSdk = (function()
{
	// Inner _AppSdk encapsulates internal implementation.
	
	/** 
	 * @classdesc This class performs UAF, U2F and FIDO2 operations.
	 * @class
	 * @alias AppSdk
	 * @description
	 * Creates a new AppSdk instance. Before using the instance should be initialized by calling the [init]{@link AppSdk#init} method with appropriate protocol.
	 * 
	 * NOTE:
	 * An AppSdk instance can by initialized by providing FIDO protocol and a [callback]{@link ready_callback} function to constructor.
	 * The callback function will be called when the instance is initialized for given protocol and is ready to use.
	 * When instance is initialized in this manner, the class methods will not return a Promise. Instead the stateCallback parameter will be mandatory
	 * and the specified function will be called also when operation has completed or failed. Methods without stateCallback parameter should be called with
	 * a callback function too.
	 */
	var _AppSdk = function(protocol, ready_callback)
	{
	
	// The flag indicates that this is a Cordova App (in cordova document URL starts with FILE)
	var isCordovaApp = (document.URL.indexOf('http://') === -1) && (document.URL.indexOf('https://') === -1);

	/** 
	 * Callback URL used in mobile app to get back to the browser.
	 * Should be the URL of RP page that invokes the app.
	 * Used when mode specifies AppSdk.MODE_LINK.
	 * @type {string}
	 */
	this.srcPage = window.location.href;
	
	/** 
	 * Registration server URL. 
	 * @type {string}
	 */
	this.regEndpoint = null;
	
	/**
	 * Authentication server URL.
	 * @type {string}
	 */
	this.authEndpoint = null;
	
	/**
	 * Specifies a base URL used to launch the mobile app or to navigate to the page if the mobile app is not installed.
	 * Used only when mode specifies AppSdk.MODE_LINK.
	 * @type {string}
	 */
	this.linkUrlBase  = "https://app.noknok.com/passport/applink.html";

	/**
	 * Domain name (without protocol) for HMS App Linking obtained from Huawei
	 * <a href="https://developer.huawei.com/consumer/en/service/josp/agc/index.html" target="_blank">AppGallery Connect</a>.
	 * 
	 * For example: <pre><code>yourapp.drcn.agconnect.link</code></pre>
	 * Used only when mode specifies AppSdk.MODE_LINK.
	 * @type {string}
	 */
	this.hmsDomain = '';

	/**
	 * The package name of the Android application that should be opened with the HMS App Link.
	 * @type {string}
	 */
	this.hmsAndroidPackage = '';

	/**
	 * Allows to enable or disable HMS App Linking. By default the HMS App Linking will be enabled on Huawei devices
	 * that support HMS but don't support GMS.
	 * @type {boolean}
	 */
	this.enableHmsAppLink = (navigator.userAgent.match('HMSCore') && !navigator.userAgent.match('GMSCore'));

	/**
	 * Mode - Specifies the mode used by AppSdk methods. The following modes are defined: 
	 * AppSdk.MODE_OOB    - The FIDO operation is performed on the other (mobile) device.
	 * AppSdk.MODE_LINK   - The FIDO operation is performed in a native mobile App launched from a mobile browser. This mode works only in a mobile browser.
	 * AppSdk.MODE_NATIVE - The FIDO operation is performed natively by browser or hosting app if the SDK is used in a Cordova app.
	 * @type {string}
	 */
	this.mode = AppSdk.MODE_AUTO;
	
	var refThis = this;

	var fidoProtocol;
	var applinkTarget = "";

	/**
	 * Reference to the promise which will be resolved when AppSdk instance is ready.
	 * @private
	 */
	var isReady = null;

	// This field is used for backward compatibility for a code that uses AppSdkWrapper.appSdk field to set some appSdk properties.
	this.appSdk = this;

	// Flag indicating whether the SDK will be used with promised or callbacks.
	var isPromiseSdk = (typeof ready_callback !== 'function');

	// OOBMethodUI instance.
	var oobMethodUI = null;

	function isFIDO2CompatibleBrowser (){
    	// if PublicKeyCredential is defined then FIDO2 is supported.
		return (window.PublicKeyCredential) ? true : false;
    }

	function isFIDO2SupportedForCordova () {
		// If not a cordova app - just return false.
		if (!isCordovaApp) {
			return false;
		}
        // if Android version is 7 ++ then FIDO2 is supported.
        if(device.platform === "Android" && device.version.split('.')[0] >= 7) {
            return true;
        }
        // if iOS version is 14 ++ then FIDO2 is supported.
		if(device.platform === "iOS" && device.version.split('.')[0] >= 14) {
            return true;
        }
        return false;
	}

	/**
	* Sets the FIDO protocol (AppSdk.PROTOCOL_FIDO2, AppSdk.PROTOCOL_UAF or AppSdk.PROTOCOL_U2F).
	* The AppSdk supports three types of FIDO protocol: FIDO2, UAF and U2F.
	* AppSdk.PROTOCOL_FIDO2 - FIDO 2.0 and W3C Web Authentication (see https://www.w3.org/TR/webauthn/)
	* AppSdk.PROTOCOL_UAF - to perform FIDO (UAF) protocol;
	* AppSdk.PROTOCOL_U2F - to perform FIDO universal second factor (U2F) protocol;
	* @param {string} protocol FIDO protocol to use.
    */
	this.setFIDOProtocol = function(protocol){
		fidoProtocol = validateProtocol(protocol); 
		
		if((fidoProtocol === AppSdk.PROTOCOL_FIDO2) && 
			(!isFIDO2CompatibleBrowser() && !isFIDO2SupportedForCordova())) {
			throw new AppSdkException(Outcome.NOT_INSTALLED);	
		}
	}
	
	/**
	 * Creates a new AppSdk instance for the given protocol
	 * and returns a Promise which resolves when the AppSdk instance is ready.
	 * @param {string} [protocol] - Specifies FIDO protocol: "uaf", "u2f" or "fido2".
	 * If not specified, protocol will be determined based on available protocols and server policy.
	 * @returns {Promise} A Promise which resolves when AppSdk is ready to use.
	 * A Promise can be rejected with {INVALID_ARGUMENT_EXCEPTION} when incorrect arguments are passed-in,
	 * or {AppSdkException} when protocol is not supported by Browser.
	 */
	this.init = function(protocol) {
		// If init is called first time, create and store the ready Promise
		if(isReady === null) {
			// missing forEach on NodeList for IE11
			if (window.NodeList && !NodeList.prototype.forEach) {
			  NodeList.prototype.forEach = Array.prototype.forEach;
			}

			// Initialize SDK only after all dependencies are loaded.
			isReady = nnl.appSdkLoaded.then(function() {
				refThis.setFIDOProtocol(protocol);
				// Initialize the tabulator instance.
				Tabulator.getInstance();
			}).then(function() {
				return new Promise(function(resolve) {
					initInstance(fidoProtocol, resolve);
				});
			});
		}

		return isReady;
	}

	/**
	 * @private
	 */
	function getMessage(opType, sessionData, extras) {
		var msg = {
			op : opType,
			fidoProtocol : fidoProtocol,
			session : sessionData,
			srcPage : refThis.srcPage,
			extras: extras || {}
		}

		if(opType === 'AUTH' || opType === 'TRANS') {
			msg.endPoint = refThis.authEndpoint;
			// If a URL for webOOB is set in AppSdkConfig and is not specified in extras,
			// copy the configured one into extras.
			if(msg.extras.webUrl == null && AppSdkConfig.oob.authBaseUrl !== '') {
				msg.extras.webUrl = AppSdkConfig.oob.authBaseUrl;
			}
		} else {
			msg.endPoint = refThis.regEndpoint;
			// If a URL for webOOB is set in AppSdkConfig and is not specified in extras,
			// copy the configured one into extras.
			if(msg.extras.webUrl == null && AppSdkConfig.oob.regBaseUrl !== '') {
				msg.extras.webUrl = AppSdkConfig.oob.regBaseUrl;
			}
		}

		// OOB mode is relevant only for REG, AUTH, TRANS and CANCEL operations.
		if(opType === 'REG' || opType === 'AUTH' || opType === 'TRANS' || opType === 'CANCEL') {
			msg.appSdkMode = refThis.mode;
			if(msg.appSdkMode === AppSdk.MODE_AUTO) {
				// Use OOB on the web with UAF protocol as native UAF is not supported.
				if(fidoProtocol === AppSdk.PROTOCOL_UAF && !isCordovaApp) {
					msg.appSdkMode = AppSdk.MODE_OOB;
				} else {
					msg.appSdkMode = AppSdk.MODE_NATIVE;
				}
			}
		}

		return msg;
	}
	
	/**
	 * @private
	 */
	function isUafLinkMode() {
		return (fidoProtocol === AppSdk.PROTOCOL_UAF) && (refThis.mode === AppSdk.MODE_LINK)
	}

	function openLink(callback, initHandle) {
		if (typeof initHandle !== 'object' || !initHandle) {
			throw new INVALID_ARGUMENT_EXCEPTION('initHandle');
		}

		// In some cases ajax call is being terminated because browser is in background and
		// operation fails when focus is returned to browser again.
		// So don't send FINISH operation to iframe to not trigger status polling at this point,
		// just store callback. onFocus handler will send FINISH and start polling.
		cbMap[initHandle.opID] = callback;

		var appLink = refThis.linkUrlBase +
				(refThis.linkUrlBase.indexOf("?") === -1 ? "?" : "&") +
				"link_data=" + linkDataMap[initHandle.opID];
		delete linkDataMap[initHandle.opID];

		linkOperationOpID = initHandle.opID;

		// There is an issue on iOS Safari when opening Applink with target="_self".
		// First time it works as expected, but then, if page is not reloaded and other navigation
		// did not happen, Safari opens the url instead of opening the app. When specifying
		// target="_blank", this issue does not happen. But in case of AppAuth, an SFSafariViewController
		// is used, which fails to open app in case of target="_blank".
		// As a new instance of SFSafariViewController is created on every operation, target="_self"
		// works fine for this case. In summary, specifying target="_self" for the first call,
		// then changing it to "_blank" for iOS Safari on next call covers all issues.
		if(applinkTarget === "") {
			// For the first time use "_self" (works for iOS Safari and SFSafariViewController)
			applinkTarget = "_self";
		} else {
			var isMobileSafari = (/iPad|iPhone|iPod/.test(navigator.userAgent) &&
					navigator.userAgent.match('Safari') &&
					!navigator.userAgent.match('CriOS') &&
					!navigator.userAgent.match('FxiOS'));
			// On the next call set target to "_blank" for iOS Safari.
			applinkTarget = isMobileSafari ? "_blank" : "_self";
		}

		// If HMS AppLinking is enabled (either explicitly or by default) and configured,
		// wrap the appLink into the HMS appLink.
		if(refThis.enableHmsAppLink && refThis.hmsDomain !== '') {
			appLink = 'https://' + refThis.hmsDomain + '?deeplink=' + encodeURIComponent(appLink);
			if(refThis.hmsAndroidPackage !== '') {
				appLink += '&android_package_name=' + refThis.hmsAndroidPackage
			}
		}

		window.open(appLink, applinkTarget);
	}

	function updateOOBUI(oobState) {
		// Create a method object to use with MethodUI instance.
		var method = {
			type: AdaptiveType.FIDO_OOB,
			state: MethodState.AWAITING_USER_ACTION,
			data: {}
		}

		if(oobState.oob === 'START') {
			// Create MethodUI instance when OOB operation starts.
			oobMethodUI = MethodUIFactory.getInstance().createMethodUI(method.type, {qrType: oobState.qrType});
			var opType = oobState.op === 'REG' ? OperationType.REGISTRATION : OperationType.AUTHENTICATION;

			// First call getInitData to initialize the instance with operation type.
			oobMethodUI.getInitData([method], opType).then(function() {
				// Then create method data structure with available fields and call getUpdateData.
				method.data = {
					modeResult: {
						qrCode: {
							qrImage: oobState.qr
						},
						rawData: oobState.rawData,
						push: {
							status: oobState.pushStatus
						}
					}
				}
				return oobMethodUI.getUpdateData(method);
			}).then(onUIResult);
		} else {
			// On subsequent calls call getUpdateData with available fields.
			method.lifetimeMillis = oobState.millis;
			if(oobState.device) {
				method.data = {
					additionalInfo: {
						device: {
							info: oobState.device
						}
					}
				}
			}

			oobMethodUI.getUpdateData(method).then(onUIResult);
		}

		function onUIResult(uiResult) {
			// If user has cancelled from the UI, cancel the operation and hide UI.
			if(uiResult.state === OperationState.OP_CANCEL) {
				refThis.cancel();
				if(typeof oobMethodUI.finish === 'function') {
					oobMethodUI.finish();
				}
				oobMethodUI = null;
			}
		}
	}

	/**
	 * Creates a callback for AppSdk methods based on the resolve and reject callbacks of a Promise.
	 * @param {function} resolve - Callback that resolves a Promise.
	 * @param {function} reject - Callback that rejects a Promise.
	 * @param {function} [stateCallback] - Callback that will be called when background fetch state changes.
	 * @returns {function} A callback function that will call resolve or reject
	 * based on the 'outcome' filed of the response .
	 * @private
	 */
	function createCallback(resolve, reject, stateCallback) {
		var settled = false;
		return function(response) {
			if (response.state) {
				// If a custom state callback is provided, call it, otherwise update OOB UI with received state.
				if(typeof stateCallback === 'function') {
					stateCallback(response);
				} else {
					updateOOBUI(response.state);
				}
				return;
			}
			// If callback is called first time, resolve or reject the promise,
			// otherwise call stateCallback (if provided).
			if(!settled) {
				// Hide OOB UI when operation is completed.
				if(oobMethodUI) {
					if(typeof oobMethodUI.finish === 'function') {
						oobMethodUI.finish();
					}
					oobMethodUI = null;
				}

				settled = true;
				if(response.outcome === Outcome.SUCCESS) {
					resolve(response);
				} else {
					reject(response);
				}
			} else if(typeof stateCallback === 'function') {
				stateCallback(response);
			}
		}
	} 

	function convertWebOobArgs(url) {
		if(url.indexOf('#nnl-oobdata=') === -1) {
			throw new INVALID_ARGUMENT_EXCEPTION('oobData');
		}

		var oobData = url.split('#nnl-oobdata=')[1];
		oobData = decodeURI(oobData);
		var s = oobData.split('|');

		if(s.length < 2) {
			throw new INVALID_ARGUMENT_EXCEPTION('oobData');
		}

		var opType = s[1] === 'a' ? 'AUTH' : 'REG';

		return {
			opType: opType,
			oobData: oobData
		}
	}

	/**
	 * Parses arguments of interface function.
	 * @private
	 */
	function parseArguments(opType, args) {
		// Convert JS arguments object into an array.
		args = [].slice.call(args);
		// Object that will contain parsed arguments.
		var result = {};

		// Look for a function in argument list.
		var callbackArg = null;
		for(var i = 0; i < args.length; i++) {
			if(typeof args[i] === 'function') {
				// Remove the function from argument list and store as callback.
				callbackArg = args.splice(i, 1)[0];
				break;
			}
		}

		let callback;
		if(isPromiseSdk) {
			// If SDK is used with Promises, create a promise, which will be returned to the caller,
			// and a callback function which will resolve or reject the promise.
			result.promise = new Promise(function(resolve, reject) {
				// Use the provided callback argument as state callback.
				callback = createCallback(resolve, reject, callbackArg);
			});
		} else {
			// Otherwise, use the provided callback argument as callback.
			callback = callbackArg;
		}
		if (opType === 'AUTH') {
			Tabulator.getInstance().startTimer(MetricName.AUTH_TIME)
		}

		result.callback = function (res) {
			callback(res);
			if (opType === 'AUTH') {
				Tabulator.getInstance().updateMetricTime(MetricName.AUTH_TIME);
			}
		}

		if(opType === 'WEBOOB') {
			var ret = convertWebOobArgs(args[0]);
			// Get extras from args if specified.
			if(args.length > 1) {
				result.extras = args[1];
			} else {
				result.extras = {};
			}

			result.extras.webOob = true;
			result.extras.oobData = ret.oobData;

			return {
				opType: ret.opType,
				args: result
			}
		}

		// For check registration possible operation set opType to REG and checkPolicy flag.
		if(opType === 'CHECK_REG') {
			opType = 'REG';
			result.checkPolicy = true;
		} else {
			result.checkPolicy = false;
		}

		// First argument is always sessionData. Retrieve it and remove it from array.
		result.sessionData = args.shift();

		// For transaction next argument is transaction id.
		if(opType === 'TRANS') {
			// Get transaction id and remove it from array.
			result.transID = args.shift();
		}

		// For deregistration and update registration next argument is registration handle.
		if(opType === 'DEREG' || opType === 'UPDATE_REG') {
			// Get registration handle and remove it from array.
			result.regHandle = args.shift();
			// Since regHandle is required for both UPDATE_REG and DEREG operations, throw exception if it is null or undefined.
			if (result.regHandle == null) {
				throw new INVALID_ARGUMENT_EXCEPTION('regHandle');
			}
			// For update registration there is also registration data.
			if(opType === 'UPDATE_REG') {
				result.registrationData = args.shift();
			}
		}

		// For dereg all only sessionData and extras are parsed
		if (opType === 'DEREG_ALL') {
			opType = 'DEREG';
		}

		// If present, next argument should be extras.
		if(args.length > 0) {
			// Get extras and remove it from array.
			result.extras = args.shift();
		}

		// If present, next argument should be init handle.
		if(args.length > 0) {
			// Get init handle and remove it from array.
			result.initHandle = args.shift();
		}

		return {
			opType: opType,
			args: result
		};
	}

	function validateAndCall(method, opType, args) {
		// Parse and validate arguments.
		var ret = parseArguments(opType, args);
		opType = ret.opType;
		args = ret.args;

		// The SDK can be initialized without protocol, but some operations require protocol to be set.
		if(fidoProtocol == null && opType === 'DEREG') {
			var logMsg = 'Protocol cannot be empty for ' + opType + ' operation.';
			console.error(logMsg);
			throw new INVALID_ARGUMENT_EXCEPTION('protocol');
		}

		// Session data should be object.
		if (args.sessionData && typeof args.sessionData !== 'object') {
			throw new INVALID_ARGUMENT_EXCEPTION('sessionData');
		}

		// Transaction ID should be string.
		if (args.transID && typeof args.transID !== 'string' ) {
			throw new INVALID_ARGUMENT_EXCEPTION('transactionID');
		}

		// Registration handle should be string.
		if (args.regHandle && typeof args.regHandle !== 'string' ) {
			throw new INVALID_ARGUMENT_EXCEPTION('regHandle');
		}

		// Registration data should be object.
		if (args.registrationData && typeof args.registrationData !== 'object') {
			throw new INVALID_ARGUMENT_EXCEPTION('registrationData');
		}

		// Extras should be object.
		if (args.extras && typeof args.extras !== 'object') {
			throw new INVALID_ARGUMENT_EXCEPTION('extras');
		}

		// Callback is mandatory if SDK is used without Promises. 
		if(!isPromiseSdk && typeof args.callback !== 'function') {
			throw new INVALID_ARGUMENT_EXCEPTION('stateCallback');
		}

		// Call the method.
		method(opType, args);

		// Return the promise created when the SDK is used with Promises
		return args.promise;
	}

	/**
	 * Parses and validates arguments and calls the given method.
	 * @private
	 */
	function checkedCall(method, opType, args) {
		if(isPromiseSdk) {
			// When the SDK is used with Promises, call the desired method after the SDK is ready.
			return isReady.then(function() {
				try {
					return validateAndCall(method, opType, args);
				} catch(e) {
					// Return validation exception in a rejected Promise.
					return Promise.reject({
						outcome: Outcome.FAILURE,
						errorDesc: e
					});
				}
			});
		} else {
			// When Promises are not in use, call the desired method directly.
			validateAndCall(method, opType, args);
		}
	}

	/**
	 * Executes initRegister, initAuthenticate and initTransact operations.
	 * @private
	 */
	function initOperation(opType, args) {
		validateProtocolAgainstMode(fidoProtocol, refThis.mode);
		
		if (!isUafLinkMode()) {
			var response =  {
					outcome : Outcome.SUCCESS,
					opType : opType,
					fidoProtocol : fidoProtocol
			};
			args.callback(response);
		} else {
			createAndSendMessage(opType, args);
		}
	}

	/**
	 * Executes register, authenticate and transact operations.
	 * @private
	 */
	function completeOperation(opType, args) {
		validateProtocolAgainstMode(fidoProtocol, refThis.mode);

		if (isUafLinkMode()) {
			if (args.initHandle) {
				openLink(args.callback, args.initHandle);
			} else {
				// If initHandle is not present in link mode
				// Save the callback of current operation to be able to return response to the caller.
				var callback = args.callback;
				// Create a new callback for 'initOperation'.
				args.callback = function(response) {
					// Use the saved callback to return result to the caller.
					if (response.outcome === Outcome.SUCCESS) {
						openLink(callback, response.initHandle);
					} else {
						callback(response);
					}
				}

				// Execute 'initOperation' by simply sending message to the iframe.
				createAndSendMessage(opType, args);
			}
		} else {
			createAndSendMessage(opType, args);
		}
	}

	/**
	 * Replace register operation args callback for to handle operation complete
	 * @private
	 */
	function completeRegOperation(opType, args) {
		var callback = args.callback;
		
		args.callback = function(response) {
			if(!response.state) {
				// only for success finish reg call operation result listener for caching
				if (response.outcome === Outcome.SUCCESS) {
					var operationData = NNLUtils.createOperationData(response);
					OperationResultListenerFactory.getListenerInstance().onComplete(FidoOperationType.REG, operationData, args.extras);
				} else {
					OperationResultListenerFactory.getListenerInstance().onFailure(FidoOperationType.REG, 
						{ outcome: response.outcome, 
						  additionalInfo: response.additionalInfo,
						  serverStatusCode: response.statusCode
						});
				}
			}
			callback(response);
		}
		completeOperation(opType, args);
	}

	/**
	 * Retrieves registrations for both UAF and FIDO2 protocols
	 * @private
	 */
	function getAllRegistrations(opType, args) {
		// Get the list of excluded authenticators from extras for filtering.
		var extras = args.extras || {};
		var excludeAuthenticators = extras.excludeAuthenticators || [];

		// Create and send a message with the specified protocol.
		var msg = getMessage(opType, args.sessionData, args.extras);
		sendMessage(msg, function(result) {
			// In case of success filter the authenticators if filter list is provided.
			if(result.outcome === Outcome.SUCCESS) {
				result.registrations.forEach(function(registration) {
					// Filter the authenticators and add the protocol filed to the ones that are not excluded.
					registration.authenticators = registration.authenticators.filter(function(authenticator) {
						try {
							// Parse the handle to get the protocol and AAID/AAGUID.
							var decodedHandle = atob(authenticator.handle.replace(/-/g, '+').replace(/_/g, '/'));
							decodedHandle = JSON.parse(decodedHandle);
							// Keep authenticator if it is not in the exclude list.
							if(excludeAuthenticators.indexOf(decodedHandle[1]) === -1) {
								// Add the protocol filed to the authenticator when keeping it.
								authenticator.protocol = decodedHandle[0].indexOf('web') !== -1 ? AppSdk.PROTOCOL_FIDO2 : AppSdk.PROTOCOL_UAF;
								return true;
							}
						} catch(e) {
							console.error('Failed to parse authenticator handle' + authenticator.handle + '. Error: ' + e);
						}

						return false;
					});
				});
			}

			args.callback(result);
		});
	}

	/**
	 * Creates a message and sends it to the iframe.
	 * @private
	 */
	function createAndSendMessage(opType, args) {
		var msg = getMessage(opType, args.sessionData, args.extras);

		msg.checkPolicy = args.checkPolicy;

		if(args.transID) {
			msg.transID = args.transID;
		}

		if(args.regHandle) {
			msg.regHandle = args.regHandle;
			if(args.registrationData) {
				msg.registrationData = args.registrationData;
			}
		}

		if(msg.appSdkMode !== AppSdk.MODE_NATIVE) {
			msg.oobPollingInterval = AppSdkConfig.oob.pollingInterval;
		}

		Promise.resolve()
		.then(function() {
			if(msg.appSdkMode === AppSdk.MODE_NATIVE && fidoProtocol !== AppSdk.PROTOCOL_U2F &&
					(opType === 'AUTH' || opType === 'REG' || opType === 'TRANS')) {
				// If a protocol was specified during initialization, use that as list of supported protocols.
				var protocols = null;
				if(fidoProtocol != null) {
					protocols = [fidoProtocol];
				}
				return NNLUtils.getInitMessage(opType, args.extras, protocols);
			}
		})
		.then(function(initMessage) {
			if(initMessage) {
				msg.initMessage = initMessage;
			}

			storeMessage(msg);
			sendMessage(msg, args.callback);
		}).catch(function(outcome) {
			args.callback({outcome: outcome});
		});
	}

	/**
	 * Prepares a data for registration operation started in subsequent App SDK register call.
     * When data is about to expire, it will be automatically updated by initiating a new background prefetch.
     * @param {SessionData} sessionData - Session data required for registration operation. 
     * If it is not present, the Server will fail registration operation.
     * @param {Extras} [extras] additional data to be passed to Server.
     * @param {stateCallback} [stateCallback] Callback that will be called when background fetch state changes (e.g. subsequent prefetch is failed).
     * @returns {Promise} A promise that will be resolved with {@link Result} object containing initHandle in case of success
     * and rejected with {@link Result} object containing outcome code in case of failure (see {@link Result} object description for initHandle details).
  	 * @throws {INVALID_ARGUMENT_EXCEPTION} If incorrect arguments are passed-in.
     */ 
	this.initRegister = function() {
		return checkedCall(initOperation, 'REG', arguments);
	}
	
     /**
     * Initiates FIDO authenticator registration process with the user's account.
     * @param {SessionData} sessionData - Session data containing user name trying to perform registration operation. 
     * If it is not present, the Server will fail registration operation.
     * @param {Extras} [extras] additional data to be passed to Server.
     * @param {object} [initHandle] An opaque handle returned in response.initHandle as a result of initRegister call.
     * @param {stateCallback} [stateCallback] Callback that will be periodically called with current OOB state.
     * If not provided, built-in OOB UI will be used.
     * @returns {Promise} A promise that will be resolved with {@link Result} object containing operation result in case of success
     * and rejected with {@link Result} object containing outcome code in case of failure.
     * @throws {INVALID_ARGUMENT_EXCEPTION} If incorrect arguments are passed-in.
     */ 
	this.register = function() {
		return checkedCall(completeRegOperation, 'REG', arguments);
	}

	/**
     * Checks whether a FIDO authenticator registration is possible with the user's account.
     * @param {SessionData} sessionData - Session data containing user name performing the check. 
     * If it is not present, the Server will fail the operation.
     * @param {Extras} [extras] additional data to be passed to Server.
     * @returns {Promise} A promise that will be resolved with {@link Result} object containing operation result in case of success
     * and rejected with {@link Result} object containing outcome code in case of failure.
     * @throws {INVALID_ARGUMENT_EXCEPTION} If incorrect arguments are passed-in.
     */ 
	this.checkRegPossible = function() {
		return checkedCall(completeOperation, 'CHECK_REG', arguments);
	}

	/**
	 * Prepares a data for authentication operation started in subsequent App SDK authenticate call.
     * When data is about to expire, it will be automatically updated by initiating a new background prefetch.
     * @param {SessionData} sessionData - Session data for the operation.
     * This is an optional parameter, used for step-up authentication.
     * @param {Extras} [extras] additional data to be passed to Server.
     * @param {stateCallback} [stateCallback] Callback that will be called when background fetch state changes (e.g. subsequent prefetch is failed).
     * @returns {Promise} A promise that will be resolved with {@link Result} object containing initHandle in case of success
     * and rejected with {@link Result} object containing outcome code in case of failure (see {@link Result} object description for initHandle details).
  	 * @throws {INVALID_ARGUMENT_EXCEPTION} If incorrect arguments are passed-in.
     */ 
	this.initAuthenticate = function() {
		return checkedCall(initOperation, 'AUTH', arguments);
	}
	
	/**
     * Initiate FIDO authentication using a previously registered FIDO authenticator.
     * @param {SessionData} sessionData Session data containing user name trying to perform authentication. 
     * This is optional parameter, used for step-up authentication.
     * @param {Extras} [extras] additional data to be passed to Server.
     * @param {object} [initHandle] An opaque handle returned in response.initHandle as a result of initAuthenticate call.
     * @param {stateCallback} [stateCallback] Callback that will be periodically called with current OOB state.
     * If not provided, built-in OOB UI will be used.
     * @returns {Promise} A promise that will be resolved with {@link Result} object containing operation result in case of success
     * and rejected with {@link Result} object containing outcome code in case of failure.
     * @throws {INVALID_ARGUMENT_EXCEPTION}If incorrect arguments are passed-in.
     */
	this.authenticate = function() {
		return checkedCall(completeOperation, 'AUTH', arguments);
	}
	
	/**
	 * Prepares a data for transaction operation started in subsequent App SDK transact call.
     * When data is about to expire, it will be automatically updated by initiating a new background prefetch.
     * @param {SessionData} sessionData - Session data for the operation.
     * @param {string} transactionID Unique ID that identifies the transaction.
     * @param {Extras} [extras] additional data to be passed to Server.
     * For plain text transaction plug-in implementation, pass transaction text through extras.options.transactionText.
     * @param {stateCallback} [stateCallback] Callback that will be called when background fetch state changes (e.g. subsequent prefetch is failed).
     * @returns {Promise} A promise that will be resolved with {@link Result} object containing initHandle in case of success
     * and rejected with {@link Result} object containing outcome code in case of failure (see {@link Result} object description for initHandle details).
  	 * @throws {INVALID_ARGUMENT_EXCEPTION} If incorrect arguments are passed-in.
     */ 
	this.initTransact = function() {
		return checkedCall(initOperation, 'TRANS', arguments);
	}
	
	/**
     * Initiates FIDO transaction confirmation operation using a previously registered FIDO authenticator.
     * @param {SessionData} sessionData Session data containing user name trying to perform transaction.
     * @param {string} transactionID Unique ID that identifies the transaction.
     * @param {Extras} [extras] additional data to be passed to Server. 
     * For plain text transaction plug-in implementation, pass transaction text through extras.options.transactionText.
     * @param {object} [initHandle] An opaque handle returned in response.initHandle as a result of initTransact call.
     * @param {stateCallback} [stateCallback] Callback that will be periodically called with current OOB state.
     * If not provided, built-in OOB UI will be used.
     * @returns {Promise} A promise that will be resolved with {@link Result} object containing operation result in case of success
     * and rejected with {@link Result} object containing outcome code in case of failure.
     * @throws {INVALID_ARGUMENT_EXCEPTION} If incorrect arguments are passed-in.
     */
	this.transact = function() {
		return checkedCall(completeOperation, 'TRANS', arguments);
	}
	
	/**
     * Returns FIDO authenticators registered previously for a user.
     * @param {SessionData} sessionData Session data containing user name.
     * @param {Extras} [extras] additional data to be passed to Server.
     * @returns {Promise} A promise that will be resolved with {@link Result} object containing operation result in case of success
     * and rejected with {@link Result} object containing outcome code in case of failure.
     * @throws {INVALID_ARGUMENT_EXCEPTION} If incorrect arguments are passed-in.
     */
	this.getRegistrations = function() {
		return checkedCall(getAllRegistrations, 'LISTREG', arguments);
	}
	
	/* Added only for backward compatibility (use getRegistrations instead). */
	this.get_registrations = this.getRegistrations;
	
	/**
     * Delete registered authenticator(s) for a given user from the Server.
     * @param {SessionData} sessionData Session data containing user name.
     * @param {string} regHandle Uniquely identifies a registration for the user. 
     * This is provided in the response of the list operation. 
     * @param {Extras} [extras] additional data to be passed to Server.
     * @returns {Promise} A promise that will be resolved with {@link Result} object containing operation result in case of success
     * and rejected with {@link Result} object containing outcome code in case of failure.
     * @throws {INVALID_ARGUMENT_EXCEPTION} If incorrect arguments are passed-in.
     */
	this.deregister = function() {
		return checkedCall(createAndSendMessage, 'DEREG', arguments);
	}
	
	/**
	 * Delete all registered authenticators for a given user from the Server.
	 * @param {SessionData} arguments.sessionData Session data containing user name.
	 * @param {Extras} [arguments.extras] additional data to be passed to Server.
	 * @returns {Promise} A promise that will be resolved with {@link Result} object containing operation result in case of success
	 * and rejected with {@link Result} object containing outcome code in case of failure.
	 * @throws {INVALID_ARGUMENT_EXCEPTION} If incorrect arguments are passed-in.
	 */
	this.deleteAllRegistrations = function() {
		return checkedCall(createAndSendMessage, 'DEREG_ALL', arguments);
	}

	/**
     * Log outs an user.
     * @param {SessionData} sessionData Session data containing user name.
     * @returns {Promise} A promise that will be resolved with {@link Result} object containing operation result in case of success
     * and rejected with {@link Result} object containing outcome code in case of failure.
     * @throws {INVALID_ARGUMENT_EXCEPTION} If incorrect arguments are passed-in.
     */
	this.logout = function() {
		return checkedCall(createAndSendMessage, 'LOGOUT', arguments);
	}
	
	/**
	 * Cancel already started registration/authentication operation
	 * @param {object} [initHandle] An opaque handle returned in response.initHandle as a result of [initRegister]{@link AppSdk#initRegister},
	 * [initAuthenticate]{@link AppSdk#initAuthenticate} or [initTransact]{@link AppSdk#initTransact} call.
  	 * @returns {Promise} A promise that will resolve immediately after operation is canceled. 
	 */
	this.cancel = function(initHandle) {
		var msg = getMessage("CANCEL");
		if(initHandle) {
			msg.opID = initHandle.opID; // get operation ID from init handle.
		} else {
			msg.opID = opID; // send last operation ID to cancel that operation.
		}

		sendMessage(msg);

		return isReady;
	}	
	
	/**
	 * Returns Device ID associated with the browser.
     * @returns {Promise} A promise that will be resolved with an object containing deviceID.
	 */
	this.getDeviceId = function() {
		// Wait for the utility script to load.
		var promise = nnl.appSdkLoaded.then(AppSdkInfo.getDeviceId)
		.then(function(deviceID) {
			return {
				outcome: Outcome.SUCCESS,
				deviceID: deviceID
			};
		});

		// If callback is not provided, return the promise with result.
		if(arguments.length === 0 || typeof arguments[0] !== 'function') {
			return promise;
		}

		// Otherwise call the provided callback after the promise.
		promise.then(arguments[0]);
	}

	/**
     * Fetch user information, such as the active and deleted FIDO authenticators for the specified user.
     * @param {SessionData} sessionData Session data containing user name.
     * @returns {Promise} A promise that will be resolved with {@link Result} object containing operation result in case of success
     * and rejected with {@link Result} object containing outcome code in case of failure.
     * @throws {INVALID_ARGUMENT_EXCEPTION} If incorrect arguments are passed-in.
     */
	this.fetchUserData = function() {
		return checkedCall(createAndSendMessage, 'FETCH_USER_DATA', arguments);
	}

	/**
     * Delete sensitive user information (Personally Identifiable Information)
     * @param {SessionData} sessionData Session data containing user name.
     * @returns {Promise} A promise that will be resolved with {@link Result} object containing operation result in case of success
     * and rejected with {@link Result} object containing outcome code in case of failure.
     * @throws {INVALID_ARGUMENT_EXCEPTION} If incorrect arguments are passed-in.
     */
	this.purgeUserData = function() {
		return checkedCall(createAndSendMessage, 'PURGE_USER_DATA', arguments);
	}


	/**
	 * 
	 * @param {SessionData} sessionData Session data containing user name.
     * @param {string} regHandle Uniquely identifies a registration for the user.
     * This is provided in the response of the list operation.
     * @param {object} regData Registration data to update.
     * The following keys are supported:
     * 
     * Key               | Description
     * ----------------- | --------------------------
     * authenticatorName | New name for authenticator
     * uvi               | New uvi value
     * uviStatus         | New uvi status
     * uvs               | New uvs value
     *
     * @param {Extras} [extras] additional data to be passed to Server.
     */
	this.updateRegistration = function() {
		return checkedCall(createAndSendMessage, 'UPDATE_REG', arguments);
	}

	/**
	 * Returns a view that will show the UI with FIDO authentication methods available for registration.
	 * @param {SessionData} sessionData Session data containing user name.
	 * @param {Extras} [extras] additional data to be passed to Server.
	 * @returns {FidoRegistrationView} View that will show available FIDO authentication methods.
	 */
	this.getFidoRegistrationView = function(sessionData, extras) {
		var controller = new FidoRegistrationController(sessionData, this, extras);
		return new FidoRegistrationView(controller);
	}

	function isPlatformAuthenticatorAvailable() {
		return new Promise(function(resolve) {
			if(isCordovaApp) {
				resolve(true);
			} else if(!window.PublicKeyCredential || typeof PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable !== 'function') {
				// API not available just return false.
				resolve(false);
			} else {
				PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()
				.then(resolve)
				.catch(function() {
					// In case of error return false.
					resolve(false);
				});
			}
		});
	}

	/**
	 * Allows to override display strings of built-in OOB UI.
	 *
	 * Available keys are:
	 *
	 * Key                         | Description
	 * --------------------------- | -----------
	 * registration_progress_msg   | Indicates ongoing registration operation.
	 * authentication_progress_msg | Indicates ongoing authentication operation.
	 * push_notification_msg       | Indicates that a push notification was sent. Will not be visible when QR code is displayed.
	 * oob_expire_msg              | Indicates the remaining time of current operation. __*{minutes}*__ and __*{seconds}*__ placeholders will be replaced with actual values.
	 * additional_info             | Displays additional information about current operation. Visible only when QR code is displayed.
	 * scan_qr_button_text         | Text of the QR code fallback button.
	 *
	 * @param {String} key - The display string key.
     * @param {string} value - New value of the display string.
	 */
	this.setUIDisplayString = function(key, value) {
		OOBUI.setDisplayString(key, value);
	}

	/**
	 * Validates the protocol against the allowed mode. 
	 * For UAF protocol MODE_NATIVE is allowed only in a Cordova app.
	 * @throws {INVALID_ARGUMENT_EXCEPTION} If protocol and mode combination is not valid.
	 * @private
	 */
	function validateProtocolAgainstMode(protocol, mode) {
		if(protocol === AppSdk.PROTOCOL_UAF && mode === AppSdk.MODE_NATIVE && !isCordovaApp) {
			var logMsg = "unexpected/unsupported mode ( " + mode + ") is used for the protocol " + protocol;
			console.log(logMsg);
			throw new INVALID_ARGUMENT_EXCEPTION(logMsg);	
		}
	}
	
	/**
	 * Validate FIDO protocol - protocol should be AppSdk.PROTOCOL_UAF, AppSdk.PROTOCOL_U2F or AppSdk.PROTOCOL_FIDO2
	 * @param {string} [protocol] FIDO protocol to use.
	 * @throws {INVALID_ARGUMENT_EXCEPTION} If protocol not valid.  
	 * @private
	 */
	function validateProtocol(protocol) {
		// As AppSdk can be initialized in protocol agnostic mode, validate protocol only if specified.
		if(protocol == null) {
			return null;
		}

		if( typeof protocol !== 'string' ){
			throw new INVALID_ARGUMENT_EXCEPTION("protocol");
		}

		protocol = protocol.toLowerCase();
		if(protocol !== AppSdk.PROTOCOL_FIDO2 && protocol !== AppSdk.PROTOCOL_U2F &&  protocol !== AppSdk.PROTOCOL_UAF){
			throw new INVALID_ARGUMENT_EXCEPTION("protocol");
		}
		
		return protocol;
	}
	
	/**
	 * Invalid argument exception
	 * @param {string} argName The invalid argument's name
	 */
	function INVALID_ARGUMENT_EXCEPTION(argName) {
		this.name = argName;
		this.toString = function() {
			return 'Invalid argument "' + this.name + '"';
		}
	}

	function storeMessage(msg)
	{
		//the message will be stored only on iOS and when oobMode is AppSdk.MODE_LINK
		if(/iP(hone|ad)/.test(navigator.platform) && msg.appSdkMode === AppSdk.MODE_LINK)
			localStorage.setItem("nnl.message", JSON.stringify(msg));
	}
	
	this.resume = function(callback) 
	{	
		var messageString = localStorage.getItem("nnl.message");
		//the message will be stored only on iOS and when oobMode is AppSdk.MODE_LINK
		if(messageString)
		{
			//clear the storage
			localStorage.removeItem("nnl.message");
				
			//now create msg object from string and post it to iframe
			var msg = JSON.parse(messageString);
			resumecb = callback;

			msg.op = "RESUME";

			sendMessage(msg, callback);
		}
	}
	
	/**
	 * The method processes the url for App-less QR OOB Support.
	 * @param {string} url The web page URL that has triggered this method.
	 * @param {Extras} [extras] Additional data to be passed to Server.
	 */
	this.processOob = function() {
		this.setFIDOProtocol(AppSdk.PROTOCOL_FIDO2);
		history.pushState("", document.title, refThis.srcPage);
		return checkedCall(createAndSendMessage, 'WEBOOB', arguments); 
	}

	/**
	 * This method parses given oob data and return an object with oobRefId
	 * @param oobData Universal or standard QR Data
	 * @return {{oobRefId}} Returns oobRefId object
	 */
	this.parseOobData = function(oobData) {
		var OOB_REF_ID_INDEX = 3;
		var oobRefId;
		var oobDataSplit;

		if (oobData.split('#nnl-oobdata=').length > 1) {
			// Universal QR data case
			var oobDataUniversal = decodeURI(oobData.split('#nnl-oobdata='));
			oobDataSplit = oobDataUniversal.split("|");
		} else {
			// Standard QR data case
			oobDataSplit = oobData.split("|");
		}

		// Remove empty strings.
		oobDataSplit = oobDataSplit.filter(function(str) {
			return (str !== '');
		});
		if (oobDataSplit.length >= 4 && oobDataSplit[OOB_REF_ID_INDEX] != null) {
			oobRefId = decodeURIComponent(oobDataSplit[OOB_REF_ID_INDEX]).replace(/\+/g, ' ');
		}
		return { oobRefId: oobRefId };
	}

	/**
	 * Returns a view that will show a UI with list of registrations actions to rename or remove them.
	 * @param {SessionData} sessionData Session data indicating user who wants to manage their registrations.
	 * @param {string} regEndpoint Registration server URL
	 * @param {string} authEndpoint Authentication server URL
	 * @param {Extras} [extras] Additional data to be passed to Server
	 * @returns {ManageRegistrationsView} View that will show list of registrations and associated actions.
	 */
	this.getManageRegistrationsView = function (sessionData, regEndpoint, authEndpoint, extras) {
		var manageRegistrationsController = new ManageRegistrationsController(sessionData, regEndpoint, authEndpoint, extras);
		return new ManageRegistrationsView(manageRegistrationsController);	
	}

	// If protocol is provided, then non Promised version of AppSdk is being created.
	if(typeof protocol === 'string') {
		// Validate and set protocol before calling the async init method
		// to throw exceptions from constructor if validation fails.
		this.setFIDOProtocol(protocol);

		// Initialize the instance using the init method.
		this.init(protocol)
		.then(function() {
			// In case of success call ready_callback if provided.
			if(typeof ready_callback === 'function') {
				ready_callback();
			}
		});
	}

	} // Inner _AppSdk
	
	var IFRAME_ID = "nnl_iframe";
	var resumecb = null;
	var readyMap = {};
	var cbMap = {};
	var linkDataMap = {};
	var opID = 0;
	
	// Operation ID of the started Applink operation.
	var linkOperationOpID = null;
	
	/**
	 * @private
	 */
	var sendMessage = function (msg, cb)
	{				
		if(cb !== undefined) {
			opID++;
			cbMap[opID]=cb;
			msg.opID = opID;
		}

		msg.appName = AppSdkInfo.getAppName();
		msg.appDisplayName = AppSdkInfo.getAppDisplayName();
		msg.NNL_SDK_VERSION = AppSdkInfo.getSdkVersion();
		
		var target = document.getElementById(IFRAME_ID).contentWindow;
		var targetOrigin = NNLUtils.getOrigin(msg.endPoint);
		//in case of locally hosted app the target origin should be the target document itself
		if(document.location.protocol === "file:") {
			targetOrigin = "file://"
		}

		AppSdkInfo.getDeviceId().then(function(deviceId) {
			msg.deviceId = deviceId
			target.postMessage(msg, targetOrigin);
		});
	}
	
	/**
	 * Processes messages sent from iframe to main window.
	 * @param {object} event - Event object containing data from iframe.
	 * @private
	 */
	var messageEventHandler = function(event)
	{
		var nnlIframe = document.getElementById(IFRAME_ID);
		
		if(!(event.origin === NNLUtils.getOrigin(nnlIframe.src) && 
		   event.data && 
		   event.data.iframe_id &&
		   IFRAME_ID === event.data.iframe_id)) 
		{
			return;
		}

		if(event.data.fidoProtocol != null &&
			!(AppSdk.PROTOCOL_UAF === event.data.fidoProtocol ||
			  AppSdk.PROTOCOL_U2F === event.data.fidoProtocol ||
			  AppSdk.PROTOCOL_FIDO2 === event.data.fidoProtocol))
		{
			return;
		}

		console.log("AppSdk.messageEventHandler: ", event.data);
		var extras = event.data.extras || {};

		if (event.data.type === "nnl.iframeUxFReady")
		{
			var readyCallback = readyMap[event.data.opID].readyCallback;
			
			delete readyMap[event.data.opID];
			
			if(typeof readyCallback === "function") 
			{
				readyCallback();
			}
		}
		else if(event.data.type === 'nnl.fidoclient') {
			// Use protocol selected by server during processing.
			var decoded = atob(event.data.serverMessage.replace(/-/g, '+').replace(/_/g, '/'));
			decoded = JSON.parse(decoded);
			var fidoProtocol = (decoded.protocol.indexOf('web') !== -1 ? AppSdk.PROTOCOL_FIDO2 : AppSdk.PROTOCOL_UAF);

			var nnlCallback = function(outcome, response, extras){
				var message = {
					outcome: outcome,
					type: event.data.type,
					response: response,
					opID: event.data.opID,
					fidoProtocol: fidoProtocol,
					serverMessage:event.data.serverMessage,
					extras: extras
				}
				nnlIframe.contentWindow.postMessage(message, NNLUtils.getOrigin(nnlIframe.src));
			}

			if(fidoProtocol === AppSdk.PROTOCOL_U2F) {
				NNLUtils.loadScript('u2f-client.js')
				.then(function() {
					nnl.u2fClient.process(event, nnlCallback);
				})
				.catch(function() {
					nnlCallback(Outcome.FAILURE);
				})
			} else {
				var rpData = {
					checkPolicy: event.data.checkPolicy
				}

				nnl.FIDOClient.process(rpData, event.data.op, fidoProtocol, event.data.serverMessage, extras)
				.then(function(response) {
					response = response || {};

					if(event.data.op === 'REG' && !rpData.checkPolicy && !extras.registrationName) {
						if(!response.isPlatformAuthenticator) {
							extras.registrationName = 'Security Key';
						} else {
							var deviceName = (response.device && response.device.info) || 'UnknownDevice'
							var modality = response.modality || 'authenticator';
							extras.registrationName = deviceName + ' ' + modality;
						}
					}
					nnlCallback(Outcome.SUCCESS, response, extras);
				})
				.catch(function(response) {
					nnlCallback(response.outcome, response.exception);
				});
			}
		}
		else if(event.data.type === 'nnl.linkData')
		{
			linkDataMap[event.data.opID] = event.data.linkData;
		}
		else if (resumecb && typeof resumecb === 'function')
		{
			resumecb(event.data);
			resumecb = null;
		}
		else if (event.data.opID) {
			if(event.data.opType === 'AUTH') {
				// handle non-adaptive case for authentication
				if (event.data.outcome === Outcome.SUCCESS) {
					var operationData = NNLUtils.createOperationData(event.data, event.data.userName);
					OperationResultListenerFactory.getListenerInstance().onComplete(FidoOperationType.AUTH, operationData, extras);
				} else {
					OperationResultListenerFactory.getListenerInstance().onFailure(FidoOperationType.AUTH, {
						outcome: event.data.outcome,
						additionalInfo: event.data.additionalInfo,
						serverStatusCode: event.data.statusCode
					});
				}
			}
			else if(event.data.opType === "PURGE_USER_DATA") {
				// Delete User data from the cache on success of Purge operation and if server doesn't have registrations for the User
				if (event.data.outcome === Outcome.SUCCESS || event.data.outcome == Outcome.SERVER_USER_NOT_FOUND) {
					var activeUser = AppSdk.getActiveUser();
					if(null != activeUser) {
						OperationResultListenerFactory.getListenerInstance().setUserData(activeUser, null);
					}
				}
			}

			if (typeof cbMap[event.data.opID] === 'function') {
				// If keepCallback flag is present, this is an init operation and
				// callback should not be removed for corresponding finish operation.
				var keepCallback = event.data.keepCallback;
				delete event.data.keepCallback;
	
				// In case of init operation add the handle to the response.
				if(keepCallback) {
					event.data.initHandle = {opID: event.data.opID}
				}
	
				cbMap[event.data.opID](event.data);
				if(!keepCallback) {
					delete cbMap[event.data.opID];
				}
			}
		}
	}
	
	/**
	 * @private
	 */
	var sendInitFrame = function(opID)
	{
		var msg = 
		{
			op : "INIT",
			opID : opID,
			fidoProtocol : readyMap[opID].fidoProtocol
		};
		sendMessage(msg);
	}
	
	/**
	 * @private
	 */
	var onhashchange = function() 
	{
		//Check if the hash was changed as a result of coming back from the App
		//(the hash value is hard-coded sessionId string, used when constructed callback url for applink).
		//If so, then remove the hash from location.
		if (location.hash && (location.hash === '#1234' || location.hash.indexOf('%231234')>= 0))
		{
			history.pushState("", document.title, location.href.split('#')[0]);
		}
	}
	
	/**
	 * Checks applink operation status after browser has gained focus.
	 * @private
	 */
	var finishLinkOperaion = function() {
		if(linkOperationOpID) {
			var msg = {
				op : "FINISH",
				opID : linkOperationOpID, // send current operation ID to cancel that operation.
				oobMode: AppSdk.MODE_LINK,
				fidoProtocol : AppSdk.PROTOCOL_UAF // currently AppSdk.MODE_LINK operation is used only with AppSdk.PROTOCOL_UAF. 
			};

			linkOperationOpID = null;
			sendMessage(msg);
			console.log("Window gained focus, sending FINISH to start polling.")
		}
	}
	
	/**
	 * @private
	 */
	var initInstance = function(fidoProtocol, ready_callback)
	{
		// During initialization App SDK instance sends INIT event to iframe.
		// The iframe is supposed to reply back with nnl.iframeUxFReady event.
		// Then App SDK will notify the caller that it is ready to be used.
		// However if iframe is not yet ready to receive INIT (no event listener is assigned yet),
		// the INIT event will be lost and no chance to reply back and notify the caller.
		// Thus App SDK keeps fidoProtocol and readyCallback in the readyMap to call sendInitFrame 
		// also later when iframe is ready as indicated by nnl.iframeReady event.
		opID++;
		readyMap[opID] = { fidoProtocol : fidoProtocol, readyCallback : ready_callback };
		sendInitFrame(opID);
	}

	window.addEventListener('focus', finishLinkOperaion, false);
	// Huawei browser does not fire blur/focus events when an app is opened with applink.
	// Listen for visibilitychange event to handle applink on Huawei devices too.
	document.addEventListener('visibilitychange', function() {
		if(document.visibilityState === 'visible') {
			finishLinkOperaion();
		}
	}, false);

	window.addEventListener('hashchange', onhashchange, false);
	window.addEventListener('message', messageEventHandler, false);

	// Return inner _AppSdk
	return _AppSdk;

})();


/**
 * Returns the authenticated user's userName previously stored by calling {@link AppSdk#setActiveUser|setActiveUser}.
 * @returns {string} active user's userName
 */
AppSdk.getActiveUser = function() {
	return NNLStorage.getItem("activeUser");
}

/**
 * Stores currently active user's userName in localStorage
 * If the userName parameter is provided, stores it as the authenticated user's userName.
 * <br>If the userName parameter is not provided or is null, removes previously stored authenticated user's userName.
 * @param {string} [userName] Authenticated user's userName.
 */
AppSdk.setActiveUser = function(userName) {
	if(userName == null) {
		NNLStorage.removeItem("activeUser");
		return;
	}
	NNLStorage.setItem("activeUser", userName);
}

/**
 * Constant for UAF protocol.
 * @constant
 * @type {string}
 */
AppSdk.PROTOCOL_UAF = "uaf";

/**
 * Constant for U2F protocol.
 * @constant
 * @type {string}
 */
AppSdk.PROTOCOL_U2F = "u2f";

/**
 * Constant for FIDO2 protocol.
 * @constant
 * @type {string}
 */
AppSdk.PROTOCOL_FIDO2 = "fido2";

/**
 * Constant specifies the "native" mode.
 * @constant
 * @type {string}
 */
AppSdk.MODE_NATIVE = "native";

/**
 * Constant specifies the "auto" mode.
 * @constant
 * @type {string}
 */
AppSdk.MODE_AUTO = "auto";

/**
 * Constant specifies the "OOB" mode.
 * @constant
 * @type {string}
 */
AppSdk.MODE_OOB = "oob";

/**
 * Constant specifies the "link" mode.
 * @constant
 * @type {string}
 */
AppSdk.MODE_LINK = "link";

/**
 * Key name for an "options" object in "extras" parameter.
 * The "options" object is passed to MFAS as "optionsData" in the payload.
 * @constant
 * @type {string}
 */
AppSdk.EXTRAS_KEY_OPTIONS = "options";

/**
 * Key name for the "transactionText" property in "options" object.
 * @constant
 * @type {string}
 */
AppSdk.EXTRAS_KEY_OPTIONS_TRANSACTION_TEXT = "transactionText";

/**
 * Key name for the "policyType" property in "options" object.
 * @constant
 * @type {string}
 */
AppSdk.EXTRAS_KEY_OPTIONS_POLICY_TYPE = "policyType";

/**
 * Key name for the "contextData" property in "extras" parameter.
 * @constant
 * @type {string}
 */
AppSdk.EXTRAS_KEY_CONTEXT_DATA = "contextData";

/**
 * Key name for the "correlationId" property in "extras" parameter.
 * @constant
 * @type {string}
 */
AppSdk.EXTRAS_KEY_CORRELATION_ID = "correlationId";

/**
 * Key name for the "statusHandle" property in "extras" parameter.
 * @constant
 * @type {string}
 */
AppSdk.EXTRAS_KEY_STATUS_HANDLE = "statusHandle";

/**
 * Key name for the "registrationName" property in "extras" parameter. 
 * @constant
 * @type {string}
 */
AppSdk.EXTRA_KEY_REGISTRATION_NAME  = "registrationName";

/**
 * Key name for the "userDisplayName" property in "extras" parameter.
 * @constant
 * @type {string} 
 */
AppSdk.EXTRA_KEY_USER_DISPLAY_NAME = "userDisplayName";

/**
 * Key name for the "userName" property in "extras" parameter.
 * @constant
 * @type {string} 
 */
AppSdk.EXTRA_KEY_USER_NAME = "userName";

/**
 * Key name for the "qrType" property in "extras" parameter.
 * @constant
 * @type {string} 
 */
AppSdk.EXTRA_KEY_QR_TYPE = "qrType";

/**
 * Key name for the "webUrl" property in "extras" parameter.
 * @constant
 * @type {string} 
 */
AppSdk.EXTRA_KEY_WEB_URL = "webUrl";

/**
 * Key name for the "qrSupported" property in "extras" parameter.
 * @constant
 * @type {boolean} 
 */
AppSdk.EXTRA_KEY_QR_SUPPORTED = "qrSupported";

/**
 * @class
 * @classdesc Default implementation of IManageRegistrationsLiveData. Also is responsible for UI updates.
 * @param {ManageRegistrationsController} manageRegistrationsController The controller instance that will perform Rename, Remove and Refresh tasks
 * @param {Object} [container] An HTML element where the view should be rendered. 
 * If not specified, a default UI for manager registrations will be presented.
 */
var ManageRegistrationsUI = function(manageRegistrationsController, container) {
	var _this = this;
	var mView;
	var mDialog;
	
	if(container) {
		mView = container;
	} else {
		// Otherwise the modal dialog body will be used as the view.
		mDialog = document.querySelector('#nnl-manage-regs-dialog-ui');
		mView = mDialog.querySelector('.nnl-manage-regs-dialog-body');
	}

	/**
	 * This method gets registrations to display
	 * @param {Array[]} registrations - List of registrations to show.
	 */
	this.setMethods =  function (registrations) {
		// Clean the view then add methods.
		mView.innerHTML = '';

		if(!registrations || registrations.length === 0) {			
			mView.innerHTML = "There is no available registrations to display.";
			showPopupIfNeeded();
			return;
		}
		
		var renderedRegs = [];
		registrations.forEach(function(reg) {
			// If a registration with the same handle is already displayed, skip this one (it is the same registration).
			if(renderedRegs.indexOf(reg.handle) !== -1) {
				return;
			}

			// Remember this registration. 
			renderedRegs.push(reg.handle);
			addRegistration(reg);
		});
		
		var removeAllButton = document.querySelector('#nnl-remove-all-registrations').cloneNode(true);
		removeAllButton.removeAttribute('id');
		
		// add event handler for remove all button
		removeAllButton.addEventListener('click', function() {
			manageRegistrationsController.onRemoveAll(_this);
		});
		
		mView.appendChild(removeAllButton);
		removeAllButton.style.display = '';
		showPopupIfNeeded();
	}

	/**
	 * This method clones manage registration section template 
	 * and append registration to given container or display dialog
	 * @param {Object} reg registration object
	 * @private
	 */
	function addRegistration(reg) {
		var uiSection = document.querySelector('#nnl-manage-regs-section').cloneNode(true);
		uiSection.removeAttribute('id');

		var text = uiSection.querySelector('.nnl-method-text');
		
		// If there are no methods of given type, show message
		if(reg.length === 0) {
			text.innerText = "No registered authenticators.";
			return;
		}

		var lastUsedTime = uiSection.querySelector('#last-used-time');
		var renameButton = uiSection.querySelector('.nnl-rename-registration');
		var removeButton = uiSection.querySelector('.nnl-remove-registration');
		var regRenameDialog = document.querySelector('#nnl-reg-rename');
		var methodName = reg.authenticatorName || reg.description;
		
		text.innerText = methodName;
		lastUsedTime.innerText = getTimeDiffLabel(reg.lastUsedTimeStamp);

		renameButton.addEventListener('click', function() {
			hidePopupIfNeeded();
			
			// Set current value in the input box and select text.
			var input = document.querySelector('.nnl-reg-rename-input');
			var renameConfirmButton = removeEventListeners(document.querySelector('.nnl-reg-rename-confirm-button'));
			
			window.setTimeout(function () {
				input.value = methodName;
				input.focus();
				input.select();
			}, 0);
			
			renameConfirmButton.addEventListener('click', function (event) {
				event.preventDefault();
				regRenameDialog.style.display = 'none';
				var newName = input.value.trim();
				
				if(newName) {
					// If a new name is provided, close the popup.
					hidePopupIfNeeded();

					// If the new name is different, rename the authenticator.
					if(newName !== methodName) {
						manageRegistrationsController.onRename(reg.handle, newName, _this);							
					}
				} else {
					NNLToastMessage.show('Please provide authenticator name.');
				}
			})
			// On cancel button click hide UI and cancel process.
			// UI may have multiple cancel buttons, so add handler for all of them.
			document.querySelectorAll('.nnl-reg-rename-cancel').forEach(function(cancelButton) {
				// Remove any existing listener.
				cancelButton = removeEventListeners(cancelButton);
				cancelButton.addEventListener('click', function() {
					regRenameDialog.style.display = 'none';
					showPopupIfNeeded();
				});
			});
			regRenameDialog.style.display = 'block';
		});
		
		removeButton.addEventListener('click', function () {
			manageRegistrationsController.onRemove(reg.handle, reg.protocol, _this);				
		})

		// Add the section to the view and show it.
		mView.appendChild(uiSection);
		uiSection.style.display = '';
	}

	function getTimeDiffLabel(stamp) {
		var timeDiff = Math.floor((Date.now() - stamp) / 1000);

		var intervalType;
		var interval = Math.floor(timeDiff / (60*60*24*365));
		if(interval >= 1) {
			intervalType = 'year';
		} else {
			interval = Math.floor(timeDiff / (60*60*24));
			if(interval >= 1) {
				intervalType = 'day';
			} else {
				interval = Math.floor(timeDiff / (60*60));
				if(interval >= 1) {
					intervalType = 'hour';
				} else {
					interval = Math.floor(timeDiff / 60);
					if(interval >= 1) {
						intervalType = 'minute';
					} else {
						interval = timeDiff;
						intervalType = 'second';
					}
				}
			}
		}

		// In some cases, the server timestamp and the local browser timestamp differ by a few seconds
		// so you need to check if the difference is not a negative number
		if(interval <= 0) {
			return 'Just now';
		}

		return interval + ' ' + intervalType + (interval > 1 ? 's' : '') + ' ago';
	}

	/**
	 * This method will be called when an authentication operation is completed.
	 * @param {Outcome} outcome - The operation outcome.
	 * @param {string} [message] - Error message.
	 */
	this.onOperationCompleted = function(outcome, message) {
		showPopupIfNeeded();
		if(outcome !== Outcome.CANCELED) {
			var toastText = 'Operation completed with outcome: ' + outcome;
			if(message) {
				toastText += ('\n' + message);
			}
			NNLToastMessage.show(toastText);
		}
	}

	function showPopupIfNeeded() {
		if(mDialog) {
			// If the modal dialog is used, show it and add click handler for close button.
			mDialog.style.display = 'block';
			mDialog.querySelector('.nnl-dialog-close').addEventListener('click', hidePopupIfNeeded);
		}
	}

	function hidePopupIfNeeded() {
		if(mDialog) {
			// If the modal dialog is used, hide it and remove click handler for close button
			// (other instance may then show the same dialog and add handler).
			mDialog.style.display = 'none';
			mDialog.querySelector('.nnl-dialog-close').removeEventListener('click', hidePopupIfNeeded);
		}
	}

	// Removes event listeners of given element by recreating it.
	// Returns reference to the newly created element.
	function removeEventListeners(el) {
		var copy = el.cloneNode(true);
		el.parentNode.replaceChild(copy, el);
		return copy;
	}
}

/**
 * @class
 * @classdesc Provides methods to perform manage registrations related tasks. Used by the UI layer.
 * @param {SessionData} sessionData Session data indicating user who is trying to authenticate.
 * @param {string} regEndPoint Registration server URL
 * @param {string} authEndPoint Authentication server URL
 * @param {Extras} [extras] Additional data to be passed to Server
 */
var ManageRegistrationsController = function(sessionData, regEndPoint, authEndPoint, extras) {
	var _this = this;
	extras = extras || {};
	var appSdk = new AppSdk();
	appSdk.regEndpoint = regEndPoint;
	appSdk.authEndpoint = authEndPoint;

	// Initialize AppSdk without protocol as each operation will set a protocol it needs.
	var isReady = nnl.appSdkLoaded.then(function() {
		return appSdk.init();
	})
	.catch(function(error) {
		console.error('Failed to initialize AppSdk', error);
	});

	/**
	 * This method renames registered authenticator. 
	 * @param {string} regId Uniquely identifies a registration 
	 * @param {string} authenticatorName New name for authenticator
	 * @param {IManageRegistrationsLiveData} liveData IManageRegistrationsLiveData instance that will be notified about operation result
	 */
	this.onRename = function(regId, authenticatorName, liveData) {
		ProgressIndicator.getInstance().incCounter();
		appSdk.updateRegistration(sessionData, regId, {'authenticatorName': authenticatorName}, null)
		.then(function () {
			OperationResultListenerFactory.getListenerInstance().onComplete(FidoOperationType.RENAME_REG, {handle: regId}, extras);
			onOperationCompleted(liveData, Outcome.SUCCESS, null);
		})
		.catch(function (result) {
			onOperationCompleted(liveData, result.outcome, null);
		})
		.then(function () {
			ProgressIndicator.getInstance().decCounter();
		});
	}

	/**
	 * This method deletes registered authenticator from the Server.
	 * @param {string} registrationId  Uniquely identifies a registration
	 * @param {string} protocol FIDO protocol
	 * @param {IManageRegistrationsLiveData} liveData IManageRegistrationsLiveData instance that will be notified about operation result
	 */
	this.onRemove = function(registrationId, protocol, liveData) {
		ProgressIndicator.getInstance().incCounter();
		appSdk.setFIDOProtocol(protocol);
		appSdk.deregister(sessionData, registrationId, null)
		.then(function () {
			OperationResultListenerFactory.getListenerInstance().onComplete(FidoOperationType.DELETE_REG, {handle: registrationId}, extras);

			onOperationCompleted(liveData, Outcome.SUCCESS, null);
		})
		.catch(function (result) {
			onOperationCompleted(liveData, result.outcome, null);
		})
		.then(function () {
			ProgressIndicator.getInstance().decCounter();
		});
	}

	/**
	 * This method deletes all registered authenticators from the Server.
	 * @param {IManageRegistrationsLiveData} liveData IManageRegistrationsLiveData instance that will be notified about operation result
	 */
	this.onRemoveAll = function(liveData) {
		ProgressIndicator.getInstance().incCounter();
		appSdk.setFIDOProtocol(AppSdk.PROTOCOL_UAF);
		appSdk.deleteAllRegistrations(sessionData, null)
			.catch(function() {
				return;
			})
			.then(function() {
				appSdk.setFIDOProtocol(AppSdk.PROTOCOL_FIDO2);
				return appSdk.deleteAllRegistrations(sessionData, null);
			})			
			.then(function () {
				onOperationCompleted(liveData, Outcome.SUCCESS, null);
			})
			.catch(function () {
				_this.onRefresh(liveData);
			})
			.then(function () {
				ProgressIndicator.getInstance().decCounter();
			});
	}

	/**
	 * This method fetches registrations list from the server and notifies
	 * the IManageRegistrationsLiveData instance to update the UI
	 * @param {IManageRegistrationsLiveData} liveData IManageRegistrationsLiveData instance that will be notified about operation result.
	 */
	this.onRefresh = function(liveData) {
		ProgressIndicator.getInstance().incCounter();

		isReady.then(function() {
			return appSdk.getRegistrations(sessionData, extras);
		})
		.then(function(result) {
			// Create a flat list for "setMethods" and "onComplete" calls.
			var registrations = [];
			result.registrations.forEach(function(registration) {
				registration.authenticators.forEach(function(authenticator) {
					registrations.push({
						info: registration.device.info,
						device: registration.device.id,
						authenticatorName: authenticator.authenticatorName,
						push: registration.device.push,
						description: authenticator.description,
						handle: authenticator.handle,
						protocol: authenticator.protocol,
						lastUsedTimeStamp: authenticator.lastUsedTimeStamp
					});
				});
			});
			var operationData = {
				registrations: registrations
			}
			OperationResultListenerFactory.getListenerInstance().onComplete(FidoOperationType.LIST_REG, operationData, extras);
			liveData.setMethods(registrations);
		})
		.catch(function(result) {
			OperationResultListenerFactory.getListenerInstance().onFailure(FidoOperationType.LIST_REG, {outcome: result.outcome});
			// If the user does not have rergistrations, update the presentation layer with empty list.
			if(result.outcome === Outcome.SERVER_USER_NOT_FOUND) {
				liveData.setMethods([]);
			} else {
				liveData.onOperationCompleted(result.outcome, null);
			}
		})
		.then(function () {
			ProgressIndicator.getInstance().decCounter();
		});
	}

	function onOperationCompleted(liveData, outcome, message) {
		if(outcome === Outcome.SUCCESS) {
			_this.onRefresh(liveData);
		}
		liveData.onOperationCompleted(outcome, message);
	}
}

/**
 * @class
 * @classdesc Provides method to show a view with list of registrations and associated actions.
 * @param {ManageRegistrationsController} manageRegistrationsController The controller instance that will return the list and perform the actions.
 */
function ManageRegistrationsView(manageRegistrationsController) {
	/**
	 * Shows the view with list of registrations and associated actions.
	 * @param {Object} [container] An HTML element where the UI should be placed. If not specified, the UI
	 * will be displayed in a modal dialog.
	 */
	this.show = function(container) {
		var ui = new ManageRegistrationsUI(manageRegistrationsController, container);
		manageRegistrationsController.onRefresh(ui);
	}
}

/**
 * This callback function is provided by RP Webapp to be called when the AppSdk is ready to be used.
 * No AppSdk method should be called until AppSdk is ready. 
 * @callback ready_callback
 */

/**
 * This callback function is provided by RP Webapp to be called when the operation state changes.
 * @callback stateCallback
 * @param {Result} result object which includes state property.
 */

/**
 * Result object provided in resolved or rejected JS Promise.
 *
 * @type {object}
 * @name Result
 * @property {string} outcome Result code returned after processing a FIDO request (see {@link Outcome} object for possible values).
 * @property {string} opType FIDO operation: "REG", "AUTH", "TRANS", "LISTREG", "DEREG", "FETCH_USER_DATA" or "PURGE_USER_DATA".
 * @property {string} fidoProtocol type: "uaf", "u2f" or "fido2".
 * @property {object} sessionData Session data returned by the Server.
 * @property {string} sessionData.sessionKey Session information created during user authentication.
 * @property {string} userName Username of the the authenticated user.
 * @property {string} push.pushHandle Push notification handle returned from the authentication server.
 * @property {string} statusCode Status code returned from the authentication server.
 * @property {object} initHandle An opaque handle returned on successful call of initRegister, initAuthenticate and initTransact. 
 * The handle should be passed into subsequent register, authenticate and transact calls correspondingly.
 * @property {object} state OOB operation state data.
 * @property {string} state.oob OOB operation state: "START", "STATUS".
 * @property {string} state.op OOB operation name: "REG", "AUTH", "TRANS".
 * @property {boolean} state.push Indicates whether a push message was sent to second device or not. Will be present only when state.oob is "START".
 * @property {number} state.pushStatus Status code of the push operation from the server.
 * @property {string} state.qr Base64 PNG image data of QR code. Will be present only when state.oob is "START".
 * @property {QRType} state.qrType Type of the QR data. May be present when state.oob is "START".
 * @property {number} state.millis OOB operation expiration time in milliseconds. Will be present only when state.oob is "STATUS".
 * @property {string} state.device Second device information when available. Will be present only when state.oob is "STATUS".
 * @property {object} additionalErrorInfo Additional error information from Server.
 * @property {object} additionalInfo Additional information from Server.
 * @property {Array<object>} registrations A list of user's active registered FIDO authenticators in case of getRegistrations and 
 * a list of user's all registered FIDO authenticators in case of fetchUserData.
 * @property {Array<object>} methods A list of user's registered non-FIDO authentication methods.
 * @property {object} stats Deletion counts for the user's information.
 */
